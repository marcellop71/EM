import EM.SDDSBridge
import EM.EquidistBootstrap

/-!
# CRT Fiber Independence and NoAlgebraicObstruction

This file proves three families of results:

1. **Closing `NoAlgebraicObstruction`**: We show that SubgroupEscape at a prime q
   implies `NoAlgebraicObstruction (emSDDS q hq)` by connecting the SDDS multiplier
   set to the `Set.range` of `Units.mk0 (multZ q n) ...` used in `se_implies_full_generation`.

2. **CRT fiber independence**: For distinct primes p and q, the Chinese Remainder
   Theorem gives independence of residues: knowing x mod q places no constraint
   on x mod p. We formalize the surjectivity of the CRT map and derive
   divisibility independence.

3. **Death channel replenishment**: Safe extractions (primes not in the death class)
   are disjoint from death-class primes, so extracting safe primes never depletes
   the death channel.

## Main results

* `nao_set_eq_range` : the NAO generating set equals `Set.range (Units.mk0 (multZ q .) ...)`
* `se_implies_nao` : SubgroupEscape implies NoAlgebraicObstruction for emSDDS
* `crt_pair_surjective` : CRT surjectivity for pairs of residues mod distinct primes
* `dvd_independent_of_residue` : divisibility by p is independent of residue mod q
* `death_channel_disjoint` : safe extractions are disjoint from death-class primes
-/

open Mullin Euclid MullinGroup

/-! ## Part 1: Closing NoAlgebraicObstruction

The key observation: `NoAlgebraicObstruction (emSDDS q hq)` asks that the
subgroup generated by `{ u : (ZMod q)^x | exists n, (u : ZMod q) = (emSDDS q hq).mult n }`
equals top.

By `emSDDS_mult_eq_multZ`, `(emSDDS q hq).mult n = multZ q n`. So this set
is `{ u | exists n, (u : ZMod q) = multZ q n }`, which is exactly
`Set.range (fun n => Units.mk0 (multZ q n) ...)` (via `Units.ext`).

And `se_implies_full_generation` shows: given SE, closure of `Set.range ...` = top.
-/

/-- The generating set in `NoAlgebraicObstruction` for `emSDDS q hq` equals the
    `Set.range` used in `se_implies_full_generation`.

    Both describe "the set of units whose ZMod q value equals multZ q n for some n".
    The NAO set is `{ u | exists n, (u : ZMod q) = (emSDDS q hq).mult n }`, which
    by `emSDDS_mult_eq_multZ` equals `{ u | exists n, (u : ZMod q) = multZ q n }`.
    The SE set is `Set.range (fun n => Units.mk0 (multZ q n) h)`.
    These are equal because a unit u with `(u : ZMod q) = multZ q n` is uniquely
    determined as `Units.mk0 (multZ q n) h` by `Units.ext`. -/
theorem nao_set_eq_range {q : ℕ} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q) :
    { u : (ZMod q)ˣ | ∃ n : ℕ, (u : ZMod q) = (emSDDS q (IsPrime.toNatPrime hq)).mult n } =
    Set.range (fun n => Units.mk0 (multZ q n) (multZ_ne_zero hq hne n)) := by
  ext u
  simp only [Set.mem_setOf_eq, Set.mem_range]
  constructor
  · rintro ⟨n, hn⟩
    rw [emSDDS_mult_eq_multZ] at hn
    exact ⟨n, Units.ext hn.symm⟩
  · rintro ⟨n, rfl⟩
    exact ⟨n, by rw [emSDDS_mult_eq_multZ]; rfl⟩

/-- **SubgroupEscape implies NoAlgebraicObstruction for emSDDS.**

    Given SE (the global hypothesis that no proper subgroup confines all multipliers),
    `se_implies_full_generation` shows the closure of `Set.range (Units.mk0 (multZ q n) ...)`
    equals top. By `nao_set_eq_range`, this is exactly what `NoAlgebraicObstruction` asserts.

    Note: SE requires `IsPrime q` and `forall k, seq k /= q`. These are standard
    hypotheses for the EM walk at a "missing" prime q. -/
theorem se_implies_nao (hse : SubgroupEscape) (q : ℕ) (hq : Nat.Prime q)
    (hiq : IsPrime q) (hne : ∀ k, seq k ≠ q) :
    NoAlgebraicObstruction (emSDDS q hq) := by
  -- Unfold NoAlgebraicObstruction
  unfold NoAlgebraicObstruction
  -- The Fact instance in the definition uses hq; our Fact instance also uses hq.
  -- We need to show closure of the NAO set = top.
  haveI : Fact (Nat.Prime q) := ⟨hq⟩
  -- Rewrite the generating set to match se_implies_full_generation
  show Subgroup.closure
    { u : (ZMod q)ˣ | ∃ n : ℕ, (u : ZMod q) = (emSDDS q hq).mult n } = ⊤
  rw [nao_set_eq_range hiq hne]
  exact se_implies_full_generation hiq hne hse

/-- **MCBelow + PRE implies NoAlgebraicObstruction.**

    A more useful form: if MC holds below q and PRE holds (both proved for
    concrete instances), then NAO holds for emSDDS at q. This composes
    `mc_below_pre_implies_se` with `se_implies_nao`. -/
theorem mc_below_pre_implies_nao
    (hpre : PrimeResidueEscape)
    {q : ℕ} (hq : Nat.Prime q) (hiq : IsPrime q) (hne : ∀ k, seq k ≠ q)
    (hmc : mc_below q) :
    NoAlgebraicObstruction (emSDDS q hq) := by
  haveI : Fact (Nat.Prime q) := ⟨hq⟩
  unfold NoAlgebraicObstruction
  show Subgroup.closure
    { u : (ZMod q)ˣ | ∃ n : ℕ, (u : ZMod q) = (emSDDS q hq).mult n } = ⊤
  rw [nao_set_eq_range hiq hne]
  -- Use mc_below_pre_implies_se to get SE at q, then se_implies_full_generation
  have hse_q := mc_below_pre_implies_se hpre hiq hne hmc
  -- se_implies_full_generation needs the global SE, but we only have SE at q.
  -- Instead, directly prove closure = top from hse_q using the same contradiction argument.
  by_contra h
  obtain ⟨n, hn⟩ := hse_q (Subgroup.closure _) h
  exact hn (Subgroup.subset_closure ⟨n, rfl⟩)

/-! ## Part 2: CRT Fiber Independence

For distinct primes p and q, the Chinese Remainder Theorem gives surjectivity
of the map (ZMod (p * q)) -> (ZMod p) x (ZMod q). This implies that for any
pair of target residues (a, b), there exists an integer simultaneously congruent
to a mod p and b mod q. -/

/-- **CRT surjectivity for distinct primes**: for any target residues a (mod p) and
    b (mod q), there exists an integer x with x = a mod p and x = b mod q.

    This follows from the surjectivity of the CRT ring isomorphism
    `ZMod.chineseRemainder : ZMod (p * q) ≃+* ZMod p x ZMod q` composed with
    `ZMod.intCast_surjective : Z ↠ ZMod (p * q)`. -/
theorem crt_pair_surjective (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (hpq : p ≠ q)
    (a : ZMod p) (b : ZMod q) :
    ∃ x : ℤ, (x : ZMod p) = a ∧ (x : ZMod q) = b := by
  -- Lift a and b to integers
  obtain ⟨a', ha'⟩ := ZMod.intCast_surjective a
  obtain ⟨b', hb'⟩ := ZMod.intCast_surjective b
  -- p and q are coprime (distinct primes)
  have hcop : (p : ℤ).gcd q = 1 := by
    rw [Int.gcd_natCast_natCast]
    exact (Nat.coprime_primes hp hq).mpr hpq
  -- Use IsCoprime (Bezout) to get coefficients u,v with u*p + v*q = 1
  have hcop' : IsCoprime (p : ℤ) (q : ℤ) := by
    rwa [Int.isCoprime_iff_gcd_eq_one]
  obtain ⟨u, v, huv⟩ := hcop'
  -- Key Bezout facts in ZMod
  have hp0 : ((p : ℤ) : ZMod p) = 0 := by rw [Int.cast_natCast, ZMod.natCast_self]
  have hq0 : ((q : ℤ) : ZMod q) = 0 := by rw [Int.cast_natCast, ZMod.natCast_self]
  -- v*q = 1 (mod p)
  have hvq_p : (v * (q : ℤ) : ZMod p) = 1 := by
    have : (u * (p : ℤ) + v * (q : ℤ) : ZMod p) = 1 := by exact_mod_cast congr_arg ((↑) : ℤ → ZMod p) huv
    rwa [show (u * (p : ℤ) + v * (q : ℤ) : ZMod p) =
      (u : ZMod p) * ((p : ℤ) : ZMod p) + (v * (q : ℤ) : ZMod p) from by push_cast; ring,
      hp0, mul_zero, zero_add] at this
  -- u*p = 1 (mod q)
  have hup_q : (u * (p : ℤ) : ZMod q) = 1 := by
    have : (u * (p : ℤ) + v * (q : ℤ) : ZMod q) = 1 := by exact_mod_cast congr_arg ((↑) : ℤ → ZMod q) huv
    rwa [show (u * (p : ℤ) + v * (q : ℤ) : ZMod q) =
      (u * (p : ℤ) : ZMod q) + (v : ZMod q) * ((q : ℤ) : ZMod q) from by push_cast; ring,
      hq0, mul_zero, add_zero] at this
  -- Construct x using CRT formula: x = a' * (q*v) + b' * (p*u)
  refine ⟨a' * (↑q * v) + b' * (↑p * u), ?_, ?_⟩
  · -- (x : ZMod p) = a: mod p, the p-term vanishes, v*q=1 gives a'
    rw [← ha']
    show (↑(a' * (↑q * v) + b' * (↑p * u)) : ZMod p) = ↑a'
    push_cast
    -- After push_cast, goal is: ↑a' * (↑q * ↑v) + ↑b' * (↑p * ↑u) = ↑a' (in ZMod p)
    -- where ↑p is (p : ZMod p), ↑q is (q : ZMod p), etc.
    have hp0' : (p : ZMod p) = 0 := ZMod.natCast_self p
    have hvq1 : (q : ZMod p) * (v : ZMod p) = 1 := by
      have := hvq_p
      rw [show (v * (q : ℤ) : ZMod p) = (q : ZMod p) * (v : ZMod p) from by push_cast; ring] at this
      exact this
    rw [hp0', zero_mul, mul_zero, add_zero, hvq1, mul_one]
  · -- (x : ZMod q) = b: mod q, the q-term vanishes, u*p=1 gives b'
    rw [← hb']
    show (↑(a' * (↑q * v) + b' * (↑p * u)) : ZMod q) = ↑b'
    push_cast
    have hq0' : (q : ZMod q) = 0 := ZMod.natCast_self q
    have hpu1 : (p : ZMod q) * (u : ZMod q) = 1 := by
      have := hup_q
      rw [show (u * (p : ℤ) : ZMod q) = (p : ZMod q) * (u : ZMod q) from by push_cast; ring] at this
      exact this
    rw [hq0', zero_mul, mul_zero, zero_add, hpu1, mul_one]

/-- **Divisibility by p is independent of residue mod q**: for any target residue
    c mod q and any distinct prime p, there exists x with x = c mod q and p | x + 1.

    Proof: by CRT, find x = c mod q and x = -1 mod p. Then p | x - (-1) = x + 1. -/
theorem dvd_independent_of_residue (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (hpq : p ≠ q)
    (c : ZMod q) :
    ∃ x : ℤ, (x : ZMod q) = c ∧ (p : ℤ) ∣ (x + 1) := by
  -- We want x = -1 (mod p) and x = c (mod q)
  obtain ⟨x, hxp, hxq⟩ := crt_pair_surjective p q hp hq hpq (-1 : ZMod p) c
  refine ⟨x, hxq, ?_⟩
  -- x = -1 (mod p) means p | x + 1
  rw [show x + 1 = x - (-1) from by ring]
  rw [← ZMod.intCast_zmod_eq_zero_iff_dvd]
  simp only [Int.cast_sub, Int.cast_neg, Int.cast_one, sub_eq_zero]
  exact hxp

/-- **CRT independence for unit residues**: for distinct primes p and q, any pair
    of units (a, b) in (ZMod p)^x x (ZMod q)^x can be realized by some integer.

    This is the unit-level version of CRT surjectivity. -/
theorem crt_unit_pair_surjective (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (hpq : p ≠ q)
    (a : (ZMod p)ˣ) (b : (ZMod q)ˣ) :
    ∃ x : ℤ, (x : ZMod p) = (a : ZMod p) ∧ (x : ZMod q) = (b : ZMod q) :=
  crt_pair_surjective p q hp hq hpq (a : ZMod p) (b : ZMod q)

/-! ## Part 3: Death Channel Replenishment

In the Euclid-Mullin walk mod q, the "death value" is -1 (since walkZ q n = -1
means q | prod(n) + 1). A prime p is a "death-class prime" (mod q) if its
residue class mod q is the death class -c^{-1} for the current walk position c.

Safe extractions are primes whose residue class is NOT the death class. The key
observation: safe extractions are automatically disjoint from death-class primes
by definition. This means extracting safe primes never depletes the supply of
primes available in the death class. -/

/-- **Death channel disjoint from safe extractions**: if `safeSet` consists of
    natural numbers whose ZMod q values avoid a target `t`, and `deathSet`
    consists of natural numbers whose ZMod q values equal `t`, then the
    two sets are disjoint as Finsets.

    This is purely a residue-class separation argument. -/
theorem death_channel_disjoint {q : ℕ} [NeZero q]
    (t : ZMod q) (safeSet deathSet : Finset ℕ)
    (h_safe : ∀ p ∈ safeSet, (p : ZMod q) ≠ t)
    (h_death : ∀ p ∈ deathSet, (p : ZMod q) = t) :
    safeSet ∩ deathSet = ∅ := by
  rw [← Finset.disjoint_iff_inter_eq_empty]
  exact Finset.disjoint_left.mpr fun x hs hd => h_safe x hs (h_death x hd)

/-- **Death channel disjoint from safe extractions (Disjoint version)**:
    the Disjoint lattice predicate form, more composable with Mathlib API. -/
theorem death_channel_disjoint' {q : ℕ} [NeZero q]
    (t : ZMod q) (safeSet deathSet : Finset ℕ)
    (h_safe : ∀ p ∈ safeSet, (p : ZMod q) ≠ t)
    (h_death : ∀ p ∈ deathSet, (p : ZMod q) = t) :
    Disjoint safeSet deathSet := by
  rw [Finset.disjoint_iff_inter_eq_empty]
  exact death_channel_disjoint t safeSet deathSet h_safe h_death

/-- **Death class has a specific unit representative**: when the walk is at position c
    (a unit in (ZMod q)^x), the death value for the multiplier is -c^{-1}, since
    walkZ(n+1) = walkZ(n) * multZ(n) = c * m. For the walk to hit -1 at the next step,
    we need c * m = -1, i.e., m = -c^{-1}.

    This theorem records that c * (-c^{-1}) = -1, confirming the death mechanism. -/
theorem death_value_mechanism {q : ℕ} [Fact (Nat.Prime q)]
    (c : (ZMod q)ˣ) :
    (c : ZMod q) * ((-c⁻¹ : (ZMod q)ˣ) : ZMod q) = -1 := by
  simp only [Units.val_neg, Units.val_inv_eq_inv_val]
  rw [mul_neg, mul_inv_cancel₀ (IsUnit.ne_zero (Units.isUnit c))]

/-- **Residue class partition**: for a prime q and any unit target t, each prime p /= q
    either has residue t mod q or not. This trivial dichotomy underpins the
    safe/death partition. -/
theorem residue_class_dichotomy {q : ℕ} [NeZero q]
    (t : ZMod q) (p : ℕ) :
    (p : ZMod q) = t ∨ (p : ZMod q) ≠ t :=
  eq_or_ne (p : ZMod q) t

/-- **CRT ensures death channel is never empty**: for any prime q and any target
    residue class t (mod q), and any other prime p /= q, there exist integers
    in the residue class t mod q that are divisible by p.

    This means: no matter what primes have been extracted so far, as long as they
    are "safe" (not in the death class), the death class retains full density. -/
theorem death_channel_nonempty (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (hpq : p ≠ q)
    (t : ZMod q) :
    ∃ x : ℤ, (x : ZMod q) = t ∧ (p : ℤ) ∣ x := by
  -- By CRT: find x = t (mod q) and x = 0 (mod p)
  obtain ⟨x, hxp, hxq⟩ := crt_pair_surjective p q hp hq hpq (0 : ZMod p) t
  refine ⟨x, hxq, ?_⟩
  rw [← ZMod.intCast_zmod_eq_zero_iff_dvd]
  exact hxp

/-! ## Summary

### Part 1 (NoAlgebraicObstruction):
- `nao_set_eq_range` : NAO generating set = Set.range of multZ units
- `se_implies_nao` : SubgroupEscape -> NoAlgebraicObstruction (emSDDS q hq)
- `mc_below_pre_implies_nao` : MCBelow + PRE -> NoAlgebraicObstruction

### Part 2 (CRT Independence):
- `crt_pair_surjective` : CRT surjectivity for two distinct primes
- `dvd_independent_of_residue` : divisibility by p independent of residue mod q
- `crt_unit_pair_surjective` : unit-level CRT surjectivity

### Part 3 (Death Channel Replenishment):
- `death_channel_disjoint` : safe set and death set are disjoint Finsets
- `death_channel_disjoint'` : Disjoint lattice version
- `death_value_mechanism` : c * (-c^{-1}) = -1 (death mechanism)
- `residue_class_dichotomy` : each element is in the target class or not
- `death_channel_nonempty` : death class has elements divisible by any other prime

### Counts:
- 10 theorems, 0 definitions, 0 sorry, 0 open Props
-/
