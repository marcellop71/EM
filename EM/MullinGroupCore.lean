-- Phase 1: The Algebraic Characterization of Walk Avoidance
--
-- This file imports Mathlib's group theory infrastructure (ZMod, subgroups,
-- Fermat's Little Theorem) and uses it to analyze the residue walk from
-- Mullin.lean in algebraic terms.
--
-- The key result is the CONFINEMENT THEOREM: the walk prod(n) % q is
-- confined to the coset w(0) · H, where H is the subgroup of (ℤ/qℤ)×
-- generated by the multiplier residues. If H is a proper subgroup and
-- -1 ∉ w(0) · H, the walk can never hit -1, and HH fails for q.
--
-- The contrapositive gives: if the multiplier residues generate the full
-- group (ℤ/qℤ)×, then -1 is in the walk's coset, a necessary condition
-- for HH to hold.

import EM.MullinResidueWalk
import Mathlib.Data.ZMod.Basic
import Mathlib.Algebra.Group.Subgroup.Basic
import Mathlib.Data.Nat.Prime.Defs
import Mathlib.Tactic.Ring
import Mathlib.Algebra.Field.ZMod
import Mathlib.Algebra.Group.Subgroup.Finite

open Mullin Euclid

namespace MullinGroup

/-! ## Bridging IsPrime and Nat.Prime -/

/-- Our custom `Euclid.IsPrime` is equivalent to Mathlib's `Nat.Prime`. -/
theorem isPrime_iff_natPrime (p : Nat) : IsPrime p ↔ Nat.Prime p := by
  constructor
  · intro ⟨h1, h2⟩; exact Nat.prime_def.mpr ⟨h1, h2⟩
  · intro hp; exact ⟨hp.two_le, hp.eq_one_or_self_of_dvd⟩

/-- Convert from our IsPrime to Nat.Prime. -/
theorem IsPrime.toNatPrime {p : Nat} (h : IsPrime p) : Nat.Prime p :=
  (isPrime_iff_natPrime p).mp h

/-- Convert from Nat.Prime to our IsPrime. -/
theorem Nat.Prime.toIsPrime {p : Nat} (h : Nat.Prime p) : IsPrime p :=
  (isPrime_iff_natPrime p).mpr h

/-! ## The walk in ZMod

We lift the residue walk `prod(n) % q` from natural numbers to `ZMod q`,
where q is prime. The multiplicative structure of `(ZMod q)×` lets us
reason about subgroups and cosets. -/

/-- The walk position at step n, cast into ZMod q. -/
def walkZ (q : Nat) (n : Nat) : ZMod q := (prod n : ZMod q)

/-- The multiplier at step n+1, cast into ZMod q. -/
def multZ (q : Nat) (n : Nat) : ZMod q := (seq (n + 1) : ZMod q)

/-- **Walk recurrence in ZMod**: walkZ(n+1) = walkZ(n) * multZ(n). -/
theorem walkZ_succ (q n : Nat) :
    walkZ q (n + 1) = walkZ q n * multZ q n := by
  simp only [walkZ, multZ, prod_succ]
  push_cast
  ring

/-- **Walk initial value**: walkZ(0) = 2 in ZMod q. -/
theorem walkZ_zero (q : Nat) : walkZ q 0 = (2 : ZMod q) := by
  simp [walkZ, prod_zero]

/-! ## Multiplier nonzero and walk nonzero

When q is prime and not in the sequence, all multipliers and walk
positions are nonzero (i.e., units) in ZMod q. -/

/-- The walk position is nonzero in ZMod q when q is prime and q ∉ seq. -/
theorem walkZ_ne_zero {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q) (n : Nat) :
    walkZ q n ≠ 0 := by
  intro h
  have : (prod n : ZMod q) = 0 := h
  rw [ZMod.natCast_eq_zero_iff] at this
  exact prime_not_in_seq_not_dvd_prod hq hne n this

/-- The multiplier is nonzero in ZMod q when q is prime and q ∉ seq. -/
theorem multZ_ne_zero {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q) (n : Nat) :
    multZ q n ≠ 0 := by
  intro h
  have : (seq (n + 1) : ZMod q) = 0 := h
  rw [ZMod.natCast_eq_zero_iff] at this
  exact seq_mod_ne_zero hq hne (n + 1) (Nat.mod_eq_zero_of_dvd this)

/-! ## The Confinement Theorem

The walk is confined to the coset walkZ(0) · H, where H is any subgroup
of (ZMod q)× that contains all multiplier residues. -/

/-- **Prefix product in subgroup**: if all multipliers from step 1 to n
    have their residues in a subgroup H of (ZMod q)×, then the ratio
    walkZ(n) / walkZ(0) is in H. -/
theorem prefix_product_in_subgroup {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q)
    (H : Subgroup (ZMod q)ˣ)
    (hmult : ∀ k, k < n →
      (Units.mk0 (multZ q k) (multZ_ne_zero hq hne k)) ∈ H) :
    ∀ k, k ≤ n →
      ∃ u : (ZMod q)ˣ, u ∈ H ∧
        walkZ q k = walkZ q 0 * (u : ZMod q) := by
  intro k hk
  induction k with
  | zero => exact ⟨1, H.one_mem, by simp [mul_one]⟩
  | succ m ih =>
    obtain ⟨u, hu, huw⟩ := ih (by omega)
    have hm_lt : m < n := by omega
    have hmu := hmult m hm_lt
    refine ⟨u * Units.mk0 (multZ q m) (multZ_ne_zero hq hne m),
            H.mul_mem hu hmu, ?_⟩
    rw [walkZ_succ, huw, Units.val_mul, Units.val_mk0, mul_assoc]

/-- **Confinement Theorem (forward direction)**:

    If all multiplier residues lie in a subgroup H ≤ (ZMod q)×, then
    the walk is permanently confined to the coset walkZ(0) · H.

    This is the key algebraic constraint: if the multiplier residues
    never escape a proper subgroup, the walk can only visit |H| of
    the q-1 possible residues. -/
theorem confinement_forward {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q)
    (H : Subgroup (ZMod q)ˣ)
    (hmult : ∀ k, (Units.mk0 (multZ q k) (multZ_ne_zero hq hne k)) ∈ H)
    (n : Nat) :
    ∃ u : (ZMod q)ˣ, u ∈ H ∧
      walkZ q n = walkZ q 0 * (u : ZMod q) := by
  exact prefix_product_in_subgroup hq hne H (fun k _ => hmult k) n (Nat.le_refl n)

/-- **Confinement Theorem (reverse direction)**:

    If the walk is confined to a coset walkZ(0) · H from step 0 onward,
    then every multiplier residue lies in H.

    Proof: walkZ(n+1) = walkZ(n) * mult(n). If walkZ(n) = walkZ(0)*u
    and walkZ(n+1) = walkZ(0)*v with u,v ∈ H, then mult(n) = u⁻¹*v ∈ H. -/
theorem confinement_reverse {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q)
    (H : Subgroup (ZMod q)ˣ)
    (hconf : ∀ n, ∃ u : (ZMod q)ˣ, u ∈ H ∧
      walkZ q n = walkZ q 0 * (u : ZMod q))
    (n : Nat) :
    (Units.mk0 (multZ q n) (multZ_ne_zero hq hne n)) ∈ H := by
  obtain ⟨u, hu, hwn⟩ := hconf n
  obtain ⟨v, hv, hwn1⟩ := hconf (n + 1)
  have hrec := walkZ_succ q n
  rw [hwn1, hwn, mul_assoc] at hrec
  have hw0_ne : walkZ q 0 ≠ 0 := walkZ_ne_zero hq hne 0
  have hval : (v : ZMod q) = (u : ZMod q) * multZ q n :=
    mul_left_cancel₀ hw0_ne hrec
  -- multZ q n = u⁻¹ * v as field elements
  have hmult_val : multZ q n = ((u⁻¹ * v : (ZMod q)ˣ) : ZMod q) := by
    simp only [Units.val_mul, Units.val_inv_eq_inv_val]
    rw [hval, ← mul_assoc, inv_mul_cancel₀ u.ne_zero, one_mul]
  -- Lift to unit equality
  suffices h : Units.mk0 (multZ q n) (multZ_ne_zero hq hne n) = u⁻¹ * v by
    rw [h]; exact H.mul_mem (H.inv_mem hu) hv
  ext
  simp only [Units.val_mk0]
  exact hmult_val

/-! ## Consequences for HH

The Confinement Theorem has a clean consequence: if the multiplier
residues generate a proper subgroup H < (ZMod q)×, and -1 is not
in the coset walkZ(0) · H, then the walk never hits -1, and HH
fails for q. -/

/-- **Avoidance from confinement**: if all multipliers are in H and
    -1 ∉ walkZ(0) · H, then the walk never hits -1 (mod q). -/
theorem avoidance_of_confinement {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q)
    (H : Subgroup (ZMod q)ˣ)
    (hmult : ∀ k, (Units.mk0 (multZ q k) (multZ_ne_zero hq hne k)) ∈ H)
    (havoid : ∀ u : (ZMod q)ˣ, u ∈ H → walkZ q 0 * (u : ZMod q) ≠ -1)
    (n : Nat) :
    walkZ q n ≠ -1 := by
  obtain ⟨u, hu, huw⟩ := confinement_forward hq hne H hmult n
  rw [huw]
  exact havoid u hu

/-- **HH failure from confinement**: if all multipliers are in H and
    -1 ∉ walkZ(0) · H, then the Hitting Hypothesis fails for q.

    This is the algebraic characterization of what "failure" looks like:
    a global conspiracy where every EM prime has its residue mod q
    confined to a proper subgroup. -/
theorem hh_failure_of_confinement {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q)
    (H : Subgroup (ZMod q)ˣ)
    (hmult : ∀ k, (Units.mk0 (multZ q k) (multZ_ne_zero hq hne k)) ∈ H)
    (havoid : ∀ u : (ZMod q)ˣ, u ∈ H → walkZ q 0 * (u : ZMod q) ≠ -1) :
    ¬(∃ n, (prod n : ZMod q) = -1) := by
  intro ⟨n, hn⟩
  exact avoidance_of_confinement hq hne H hmult havoid n hn

/-! ## Bridge: walkZ = -1 ↔ q ∣ (prod n + 1)

This connects the ZMod walk to the divisibility condition in HH. -/

/-- The walk hits -1 in ZMod q iff q divides prod(n) + 1. -/
theorem walkZ_eq_neg_one_iff {q : Nat} (n : Nat) :
    walkZ q n = -1 ↔ (q ∣ (prod n + 1)) := by
  simp only [walkZ]
  constructor
  · intro h
    have h1 : (prod n : ZMod q) + 1 = 0 := by rw [h]; ring
    have h2 : ((prod n + 1 : Nat) : ZMod q) = 0 := by push_cast; exact h1
    rwa [ZMod.natCast_eq_zero_iff] at h2
  · intro h
    have h1 : ((prod n + 1 : Nat) : ZMod q) = 0 := by rwa [ZMod.natCast_eq_zero_iff]
    have h2 : (prod n : ZMod q) + 1 = 0 := by push_cast at h1; exact h1
    calc (prod n : ZMod q) = (prod n : ZMod q) + 1 - 1 := by ring
      _ = 0 - 1 := by rw [h2]
      _ = -1 := by ring

/-- **HH failure characterization**: HH fails for q iff the walk never
    hits -1, which by confinement happens iff there's a proper confining
    subgroup. -/
theorem hh_failure_iff_walk_avoids {q : Nat} [Fact (Nat.Prime q)]
    (_hq : IsPrime q) (_hne : ∀ k, seq k ≠ q) :
    (∀ n, ¬(q ∣ (prod n + 1))) ↔ (∀ n, walkZ q n ≠ -1) := by
  constructor
  · intro h n hn; exact h n ((walkZ_eq_neg_one_iff n).mp hn)
  · intro h n hn; exact h n ((walkZ_eq_neg_one_iff n).mpr hn)

/-- **-1 is nonzero in ZMod q for q ≥ 3**: needed to show -1 ∈ walkZ(0)·⊤. -/
theorem neg_one_ne_zero_of_prime_ge_three {q : Nat} [Fact (Nat.Prime q)]
    (_hq3 : q ≥ 3) : (-1 : ZMod q) ≠ 0 :=
  neg_ne_zero.mpr one_ne_zero

/-- **Full group coset contains everything nonzero**: if H = ⊤, then
    for any nonzero element a, a · H covers all nonzero elements.
    In particular, -1 ∈ a · ⊤. -/
theorem neg_one_in_top_coset {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q) (hq3 : q ≥ 3) :
    ∃ u : (ZMod q)ˣ, u ∈ (⊤ : Subgroup (ZMod q)ˣ) ∧
      walkZ q 0 * (u : ZMod q) = -1 := by
  have hw0_ne : walkZ q 0 ≠ 0 := walkZ_ne_zero hq hne 0
  have hm1_ne : (-1 : ZMod q) ≠ 0 := neg_one_ne_zero_of_prime_ge_three hq3
  refine ⟨(Units.mk0 (walkZ q 0) hw0_ne)⁻¹ * Units.mk0 (-1 : ZMod q) hm1_ne,
          Subgroup.mem_top _, ?_⟩
  simp only [Units.val_mul, Units.val_inv_eq_inv_val, Units.val_mk0]
  rw [← mul_assoc, mul_inv_cancel₀ hw0_ne, one_mul]

/-- **Generated subgroup contains all mults**: the subgroup generated by
    all multiplier residues contains every multiplier, by definition. -/
theorem mults_in_generated_subgroup {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q) :
    let S := Set.range (fun n => Units.mk0 (multZ q n) (multZ_ne_zero hq hne n))
    ∀ k, (Units.mk0 (multZ q k) (multZ_ne_zero hq hne k)) ∈ Subgroup.closure S :=
  fun k => Subgroup.subset_closure ⟨k, rfl⟩

/-! ## The algebraic landscape

The theorems above give us a complete picture of the algebraic constraints:

**Sufficient condition for HH failure** (`hh_failure_of_confinement`):
  If all mult residues lie in a proper subgroup H ⊊ (ZMod q)× AND
  -1 ∉ walkZ(0) · H, then the walk never hits -1.

**SubgroupEscape prevents this** (`se_breaks_confinement`):
  SE says no proper subgroup can confine all mults, so the first
  condition above can never be satisfied.

**Note on the gap**: SE rules out the algebraic obstruction (confinement
to a proper subgroup), but it does NOT directly imply HH. The missing
piece is a MIXING argument: even if the multiplier residues generate
the full group (ZMod q)×, the walk's prefix products might not visit
every element. Proving this mixing property would close the gap
between SE and HH. -/

/-! ## SubgroupEscape: the sufficient condition

SubgroupEscape says: for every prime q not in the sequence and every
proper subgroup H < (ZMod q)×, some multiplier residue escapes H.

This is the precise algebraic condition needed to rule out permanent
confinement, and hence to ensure the walk can potentially hit -1. -/

/-- **SubgroupEscape**: no proper subgroup can permanently confine
    all multiplier residues. -/
def SubgroupEscape : Prop :=
  ∀ (q : Nat) [Fact (Nat.Prime q)],
  ∀ (hq : IsPrime q) (hne : ∀ k, seq k ≠ q)
    (H : Subgroup (ZMod q)ˣ), H ≠ ⊤ →
  ∃ n, (Units.mk0 (multZ q n) (multZ_ne_zero hq hne n)) ∉ H

/-- **SubgroupEscape prevents permanent confinement**: if SE holds,
    the walk is not permanently confined to any proper coset. -/
theorem se_breaks_confinement {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q)
    (hse : SubgroupEscape)
    (H : Subgroup (ZMod q)ˣ) (hH : H ≠ ⊤) :
    ¬(∀ k, (Units.mk0 (multZ q k) (multZ_ne_zero hq hne k)) ∈ H) := by
  intro hall
  obtain ⟨n, hn⟩ := hse q hq hne H hH
  exact hn (hall n)

/-! ## Walk collision and cycles in ZMod

We lift the pigeonhole-based collision theorem from Mullin.lean to the
ZMod setting. The key bridge is `ZMod.natCast_eq_natCast_iff'`, which
converts mod equality to ZMod cast equality. -/

/-- **Walk collision in ZMod**: within any q consecutive steps past bound N,
    the walk revisits a previous position in (ZMod q)×. -/
theorem walkZ_has_collision {q : Nat}
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q) (N : Nat) :
    ∃ i j, N ≤ i ∧ i < j ∧ j < N + q ∧ walkZ q i = walkZ q j := by
  obtain ⟨i, j, hNi, hij, hjN, hmod⟩ := walk_has_collision hq hne N
  exact ⟨i, j, hNi, hij, hjN, (ZMod.natCast_eq_natCast_iff' _ _ q).mpr hmod⟩

/-- **Infinitely many returns**: the walk revisits states infinitely
    often. By pigeonhole, within every q steps past any bound N, the walk
    returns to a previously visited position. -/
theorem walkZ_infinitely_many_returns {q : Nat}
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q) :
    ∀ N, ∃ i j, N ≤ i ∧ i < j ∧ walkZ q i = walkZ q j := by
  intro N
  obtain ⟨i, j, hNi, hij, _, hw⟩ := walkZ_has_collision hq hne N
  exact ⟨i, j, hNi, hij, hw⟩

/-- **Cycle unit product**: when the walk returns to a visited state,
    the product of the intermediate multiplier units is 1.
    Specifically, if walkZ q i = walkZ q j with i < j, then there
    exists a unit u ∈ (ZMod q)× with u = 1 that decomposes as a product
    of the multiplier units from step i to j-1. -/
theorem walkZ_cycle_ratio_one {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q)
    {i j : Nat} (_hij : i < j) (hret : walkZ q i = walkZ q j) :
    (Units.mk0 (walkZ q i) (walkZ_ne_zero hq hne i))⁻¹ *
      Units.mk0 (walkZ q j) (walkZ_ne_zero hq hne j) = 1 := by
  ext
  simp only [Units.val_mul, Units.val_inv_eq_inv_val, Units.val_mk0, Units.val_one]
  rw [← hret]
  exact inv_mul_cancel₀ (walkZ_ne_zero hq hne i)

/-! ## SE implies full generation

SubgroupEscape immediately implies that the generated subgroup of all
multiplier residues is the full group (ZMod q)×. The proof is by
contradiction: if the closure were a proper subgroup, SE gives a
multiplier outside it — but every multiplier is in its own closure. -/

/-- **Full generation from SE**: if no proper subgroup confines all
    multiplier residues, then they generate the full group. -/
theorem se_implies_full_generation {q : Nat} [Fact (Nat.Prime q)]
    (hq : IsPrime q) (hne : ∀ k, seq k ≠ q) (hse : SubgroupEscape) :
    Subgroup.closure
      (Set.range (fun n => Units.mk0 (multZ q n) (multZ_ne_zero hq hne n))) = ⊤ := by
  by_contra h
  obtain ⟨n, hn⟩ := hse q hq hne (Subgroup.closure _) h
  exact hn (Subgroup.subset_closure ⟨n, rfl⟩)

/-! ## The Complete Reduction: SE + Mixing → Mullin's Conjecture

We decompose the HittingHypothesis (and hence Mullin's Conjecture) into
two independent hypotheses:

1. **SubgroupEscape** (algebraic): no proper subgroup of (ZMod q)×
   permanently confines all EM multiplier residues. This is about the
   *distribution* of EM primes across residue classes.

2. **MixingHypothesis** (combinatorial/dynamical): if the multiplier
   residues generate the full group (ZMod q)×, then the multiplicative
   walk prod(n) mod q visits -1 infinitely often. This is about
   *coverage* of group elements by prefix products.

The chain of implications:

    SE → full generation     (proved: se_implies_full_generation)
    full generation + Mixing → HH   (proved: se_mixing_implies_hh)
    HH → MullinConjecture           (proved in Mullin.lean)

Combined: SE + Mixing → MullinConjecture. -/

/-- **The Mixing Hypothesis**: if the multiplier residues generate the
    full multiplicative group (ZMod q)×, then the walk hits -1
    infinitely often.

    This is the "dynamical gap" between knowing the algebraic structure
    (full generation) and the actual behavior (coverage). In a cyclic
    group, full generation is necessary but not sufficient for coverage
    by prefix products — the ORDER of the multipliers matters.

    The EM sequence has a crucial structural property that should make
    mixing hold: the multipliers are ALL DISTINCT PRIMES, which prevents
    exact periodicity and forces the walk to explore new territory. -/
def MixingHypothesis : Prop :=
  ∀ (q : Nat) [Fact (Nat.Prime q)],
    ∀ (hq : IsPrime q) (hne : ∀ k, seq k ≠ q),
    Subgroup.closure
      (Set.range (fun n => Units.mk0 (multZ q n) (multZ_ne_zero hq hne n))) = ⊤ →
    ∀ N, ∃ n, N ≤ n ∧ walkZ q n = -1

/-- **SE + Mixing → HittingHypothesis**: the two hypotheses combine to
    give HH. SE provides full generation; Mixing converts it to hits. -/
theorem se_mixing_implies_hh (hse : SubgroupEscape) (hmix : MixingHypothesis) :
    HittingHypothesis := by
  intro q hq hne N
  haveI : Fact (Nat.Prime q) := ⟨IsPrime.toNatPrime hq⟩
  have hfull := se_implies_full_generation hq hne hse
  obtain ⟨n, hn, hw⟩ := hmix q hq hne hfull N
  exact ⟨n, hn, (walkZ_eq_neg_one_iff n).mp hw⟩

/-- **The Complete Conditional Reduction**:
    SubgroupEscape + MixingHypothesis → MullinConjecture.

    This decomposes Mullin's 1963 conjecture (every prime appears in the
    Euclid-Mullin sequence) into two independent number-theoretic claims
    about the distribution and mixing of prime residues mod q. -/
theorem se_mixing_implies_mullin (hse : SubgroupEscape) (hmix : MixingHypothesis) :
    MullinConjecture :=
  hh_implies_mullin (se_mixing_implies_hh hse hmix)


end MullinGroup
